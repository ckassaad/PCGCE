
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>tigramite.independence_tests.oracle_conditional_independence &#8212; Tigramite 4.2 documentation</title>
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Tigramite 4.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for tigramite.independence_tests.oracle_conditional_independence</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Tigramite causal discovery for time series.&quot;&quot;&quot;</span>

<span class="c1"># Author: Jakob Runge &lt;jakob@jakob-runge.com&gt;</span>
<span class="c1">#</span>
<span class="c1"># License: GNU General Public License v3.0</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">OrderedDict</span>


<div class="viewcode-block" id="OracleCI"><a class="viewcode-back" href="../../../index.html#tigramite.independence_tests.OracleCI">[docs]</a><span class="k">class</span> <span class="nc">OracleCI</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Oracle of conditional independence test X _|_ Y | Z given a graph.</span>

<span class="sd">    Class around link_coeff causal ground truth. X _|_ Y | Z is based on</span>
<span class="sd">    assessing whether X and Y are d-separated given Z in the graph.</span>

<span class="sd">    Class can be used just like a Tigramite conditional independence class</span>
<span class="sd">    (e.g., ParCorr). The main use is for unit testing of PCMCI methods.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    link_coeffs : dict</span>
<span class="sd">        Dictionary of form {0:[((0, -1), coeff, func), ...], 1:[...], ...}.</span>
<span class="sd">    verbosity : int, optional (default: 0)</span>
<span class="sd">        Level of verbosity.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># documentation</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">measure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concrete property to return the measure of the independence test</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_measure</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">link_coeffs</span><span class="p">,</span>
                 <span class="n">observed_vars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">verbosity</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbosity</span> <span class="o">=</span> <span class="n">verbosity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_measure</span> <span class="o">=</span> <span class="s1">&#39;oracle_ci&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">confidence</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">link_coeffs</span> <span class="o">=</span> <span class="n">link_coeffs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">link_coeffs</span><span class="p">)</span>

        <span class="c1"># Initialize already computed dsepsets of X, Y, Z</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dsepsets</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Initialize observed vars</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observed_vars</span> <span class="o">=</span> <span class="n">observed_vars</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">observed_vars</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">observed_vars</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">observed_vars</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">))):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;observed_vars must be subset of range(N).&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">observed_vars</span> <span class="o">!=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">observed_vars</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;observed_vars must ordered.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">observed_vars</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">observed_vars</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;observed_vars must not contain duplicates.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="OracleCI.set_dataframe"><a class="viewcode-back" href="../../../index.html#tigramite.independence_tests.OracleCI.set_dataframe">[docs]</a>    <span class="k">def</span> <span class="nf">set_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dummy function.&quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

    <span class="k">def</span> <span class="nf">_check_XYZ</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks variables X, Y, Z.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X, Y, Z : list of tuples</span>
<span class="sd">            For a dependence measure I(X;Y|Z), Y is of the form [(varY, 0)],</span>
<span class="sd">            where var specifies the variable index. X typically is of the form</span>
<span class="sd">            [(varX, -tau)] with tau denoting the time lag and Z can be</span>
<span class="sd">            multivariate [(var1, -lag), (var2, -lag), ...] .</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        X, Y, Z : tuple</span>
<span class="sd">            Cleaned X, Y, Z.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the length in time and the number of nodes</span>
        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>

        <span class="c1"># Remove duplicates in X, Y, Z</span>
        <span class="n">X</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">OrderedDict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">OrderedDict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">Y</span><span class="p">))</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">OrderedDict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">Z</span><span class="p">))</span>

        <span class="c1"># If a node in Z occurs already in X or Y, remove it from Z</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">Z</span> <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">X</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Y</span><span class="p">)]</span>

        <span class="c1"># Check that all lags are non-positive and indices are in [0,N-1]</span>
        <span class="n">XYZ</span> <span class="o">=</span> <span class="n">X</span> <span class="o">+</span> <span class="n">Y</span> <span class="o">+</span> <span class="n">Z</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">XYZ</span><span class="p">)</span>
        <span class="c1"># Ensure that XYZ makes sense</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">XYZ</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;X, Y, Z must be lists of tuples in format&quot;</span>
                             <span class="s2">&quot; [(var, -lag),...], eg., [(2, -2), (1, 0), ...]&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">XYZ</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nodes are </span><span class="si">%s</span><span class="s2">, &quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">XYZ</span><span class="p">)</span> <span class="o">+</span>
                             <span class="s2">&quot;but all lags must be non-positive&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">XYZ</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">N</span><span class="p">)</span>
                <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">XYZ</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;var indices </span><span class="si">%s</span><span class="s2">,&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">XYZ</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">+</span>
                             <span class="s2">&quot; but must be in [0, </span><span class="si">%d</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Y</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Y-nodes are </span><span class="si">%s</span><span class="s2">, &quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span> <span class="o">+</span>
                             <span class="s2">&quot;but one of the Y-nodes must have zero lag&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_lagged_parents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_lag</span><span class="p">,</span> <span class="n">exclude_contemp</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper function to yield lagged parents for var_lag from</span>
<span class="sd">        self.links_coeffs.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        var_lag : tuple</span>
<span class="sd">            Tuple of variable and lag which is assumed &lt;= 0.</span>
<span class="sd">        exclude_contemp : bool</span>
<span class="sd">            Whether contemporaneous links should be exluded.</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        Next lagged parent.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">var</span><span class="p">,</span> <span class="n">lag</span> <span class="o">=</span> <span class="n">var_lag</span>

        <span class="k">for</span> <span class="n">link_props</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">link_coeffs</span><span class="p">[</span><span class="n">var</span><span class="p">]:</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">tau</span> <span class="o">=</span> <span class="n">link_props</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">coeff</span> <span class="o">=</span> <span class="n">link_props</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">coeff</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">exclude_contemp</span> <span class="ow">and</span> <span class="n">lag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">lag</span> <span class="o">+</span> <span class="n">tau</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper function to get children from links.</span>

<span class="sd">        Note that for children the lag is positive.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        children : dict</span>
<span class="sd">            Dictionary of form {0:[(0, 1), (3, 0), ...], 1:[], ...}.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">link_coeffs</span><span class="p">)</span>
        <span class="n">children</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">j</span><span class="p">,</span> <span class="p">[])</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)])</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">link_props</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">link_coeffs</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                        <span class="n">i</span><span class="p">,</span> <span class="n">tau</span> <span class="o">=</span> <span class="n">link_props</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">coeff</span> <span class="o">=</span> <span class="n">link_props</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">coeff</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">:</span>
                            <span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">j</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">tau</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">children</span>

    <span class="k">def</span> <span class="nf">_get_lagged_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_lag</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="n">exclude_contemp</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper function to yield lagged children for var_lag from children.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        var_lag : tuple</span>
<span class="sd">            Tuple of variable and lag which is assumed &lt;= 0.</span>
<span class="sd">        children : dict</span>
<span class="sd">            Dictionary of form {0:[(0, 1), (3, 0), ...], 1:[], ...}.</span>
<span class="sd">        exclude_contemp : bool</span>
<span class="sd">            Whether contemporaneous links should be exluded.</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        Next lagged child.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">var</span><span class="p">,</span> <span class="n">lag</span> <span class="o">=</span> <span class="n">var_lag</span>
        <span class="c1"># lagged_parents = []</span>

        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">[</span><span class="n">var</span><span class="p">]:</span>
            <span class="n">k</span><span class="p">,</span> <span class="n">tau</span> <span class="o">=</span> <span class="n">child</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">exclude_contemp</span> <span class="ow">and</span> <span class="n">tau</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="c1"># lagged_parents.append((i, lag + tau))</span>
                <span class="k">yield</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">lag</span> <span class="o">+</span> <span class="n">tau</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_non_blocked_ancestors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;non_repeating&#39;</span><span class="p">,</span>
                                    <span class="n">max_lag</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper function to return the non-blocked ancestors of variables Y.</span>

<span class="sd">        Returns a dictionary of ancestors for every y in Y. y is a tuple (</span>
<span class="sd">        var, lag) where lag &lt;= 0. All ancestors with directed paths towards y</span>
<span class="sd">        that are not blocked by conditions in conds are included. In mode</span>
<span class="sd">        &#39;non_repeating&#39; an ancestor X^i_{t-\tau_i} with link X^i_{t-\tau_i}</span>
<span class="sd">        --&gt; X^j_{ t-\tau_j} is only included if X^i_{t&#39;-\tau_i} --&gt; X^j_{</span>
<span class="sd">        t&#39;-\tau_j} is not already part of the ancestors. The most lagged</span>
<span class="sd">        ancestor for every variable X^i defines the maximum ancestral time</span>
<span class="sd">        lag, which is also returned. In mode &#39;max_lag&#39; ancestors are included</span>
<span class="sd">        up to the maximum time lag max_lag.</span>

<span class="sd">        It&#39;s main use is to return the maximum ancestral time lag max_lag of</span>
<span class="sd">        y in Y for every variable in self.links_coeffs.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Y : list of tuples</span>
<span class="sd">            Of the form [(var, -tau)], where var specifies the variable</span>
<span class="sd">            index and tau the time lag.</span>
<span class="sd">        conds : list of tuples</span>
<span class="sd">            Of the form [(var, -tau)], where var specifies the variable</span>
<span class="sd">            index and tau the time lag.</span>
<span class="sd">        mode : {&#39;non_repeating&#39;, &#39;max_lag&#39;}</span>
<span class="sd">            Whether repeating links should be excluded or ancestors should be</span>
<span class="sd">            followed up to max_lag.</span>
<span class="sd">        max_lag : int</span>
<span class="sd">            Maximum time lag to include ancestors.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ancestors : dict</span>
<span class="sd">            Includes ancestors for every y in Y.</span>
<span class="sd">        max_lag : int</span>
<span class="sd">            Maximum time lag to include ancestors.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_repeating</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">seen_links</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Returns True if a link or its time-shifted version is already</span>
<span class="sd">            included in seen_links.&quot;&quot;&quot;</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">taui</span> <span class="o">=</span> <span class="n">link</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">j</span><span class="p">,</span> <span class="n">tauj</span> <span class="o">=</span> <span class="n">link</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">seen_link</span> <span class="ow">in</span> <span class="n">seen_links</span><span class="p">:</span>
                <span class="n">seen_i</span><span class="p">,</span> <span class="n">seen_taui</span> <span class="o">=</span> <span class="n">seen_link</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">seen_j</span><span class="p">,</span> <span class="n">seen_tauj</span> <span class="o">=</span> <span class="n">seen_link</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">seen_i</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">==</span> <span class="n">seen_j</span>
                    <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">tauj</span><span class="o">-</span><span class="n">taui</span><span class="p">)</span> <span class="o">==</span> <span class="nb">abs</span><span class="p">(</span><span class="n">seen_tauj</span><span class="o">-</span><span class="n">seen_taui</span><span class="p">)):</span>
                    <span class="k">return</span> <span class="kc">True</span>

            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">conds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">conds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">conds</span> <span class="o">=</span> <span class="p">[</span><span class="n">z</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">conds</span> <span class="k">if</span> <span class="n">z</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Y</span><span class="p">]</span>

        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">link_coeffs</span><span class="p">)</span>

        <span class="c1"># Initialize max. ancestral time lag for every N</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;non_repeating&#39;</span><span class="p">:</span>
            <span class="n">max_lag</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">max_lag</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;max_lag must be set in mode = &#39;max_lag&#39;&quot;</span><span class="p">)</span>

        <span class="n">ancestors</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">y</span><span class="p">,</span> <span class="p">[])</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">Y</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">Y</span><span class="p">:</span>
            <span class="n">j</span><span class="p">,</span> <span class="n">tau</span> <span class="o">=</span> <span class="n">y</span>   <span class="c1"># tau &lt;= 0</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;non_repeating&#39;</span><span class="p">:</span>
                <span class="n">max_lag</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_lag</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">tau</span><span class="p">))</span>
            <span class="n">seen_links</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">this_level</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span><span class="p">]</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">this_level</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">next_level</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">varlag</span> <span class="ow">in</span> <span class="n">this_level</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">par</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_lagged_parents</span><span class="p">(</span><span class="n">varlag</span><span class="p">):</span>
                        <span class="n">i</span><span class="p">,</span> <span class="n">tau</span> <span class="o">=</span> <span class="n">par</span>
                        <span class="k">if</span> <span class="n">par</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">conds</span> <span class="ow">and</span> <span class="n">par</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ancestors</span><span class="p">[</span><span class="n">y</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="p">((</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;non_repeating&#39;</span> <span class="ow">and</span>
                                <span class="ow">not</span> <span class="n">_repeating</span><span class="p">((</span><span class="n">par</span><span class="p">,</span> <span class="n">varlag</span><span class="p">),</span> <span class="n">seen_links</span><span class="p">))</span> <span class="ow">or</span>
                                <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;max_lag&#39;</span> <span class="ow">and</span>
                                 <span class="nb">abs</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">max_lag</span><span class="p">))):</span>
                                    <span class="n">ancestors</span><span class="p">[</span><span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">par</span><span class="p">)</span>
                                    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;non_repeating&#39;</span><span class="p">:</span>
                                        <span class="n">max_lag</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_lag</span><span class="p">,</span>
                                                         <span class="nb">abs</span><span class="p">(</span><span class="n">tau</span><span class="p">))</span>
                                    <span class="n">next_level</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">par</span><span class="p">)</span>
                                    <span class="n">seen_links</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">par</span><span class="p">,</span> <span class="n">varlag</span><span class="p">))</span>

                <span class="n">this_level</span> <span class="o">=</span> <span class="n">next_level</span>

        <span class="k">return</span> <span class="n">ancestors</span><span class="p">,</span> <span class="n">max_lag</span>

    <span class="k">def</span> <span class="nf">_has_any_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">conds</span><span class="p">,</span> <span class="n">max_lag</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns True if X and Y are d-connected by any open path.</span>

<span class="sd">        Does breadth-first search from both X and Y and meets in the middle.</span>
<span class="sd">        Paths are walked according to the d-separation rules where paths can</span>
<span class="sd">        only traverse motifs &lt;-- v &lt;-- or &lt;-- v --&gt; or --&gt; v --&gt; or</span>
<span class="sd">        --&gt; [v] &lt;-- where [.] indicates that v is conditioned on.</span>
<span class="sd">        Furthermore, paths nodes (v, t) need to fulfill max_lag &lt;= t &lt;= 0</span>
<span class="sd">        and links cannot be traversed backwards.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X, Y : lists of tuples</span>
<span class="sd">            Of the form [(var, -tau)], where var specifies the variable</span>
<span class="sd">            index and tau the time lag.</span>
<span class="sd">        conds : list of tuples</span>
<span class="sd">            Of the form [(var, -tau)], where var specifies the variable</span>
<span class="sd">            index and tau the time lag.</span>
<span class="sd">        max_lag : int</span>
<span class="sd">            Maximum time lag.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_walk_to_parents</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">fringe</span><span class="p">,</span> <span class="n">this_path</span><span class="p">,</span> <span class="n">other_path</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Helper function to update paths when walking to parents.&quot;&quot;&quot;</span>
            <span class="n">found_path</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_lagged_parents</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                <span class="c1"># Cannot walk into conditioned parents and</span>
                <span class="c1"># cannot walk beyond t or max_lag</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">w</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">w</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">conds</span> <span class="ow">and</span>
                    <span class="c1"># (w, v) not in seen_links and</span>
                    <span class="n">t</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">max_lag</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="s1">&#39;tail&#39;</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">this_path</span> <span class="ow">and</span> 
                        <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">this_path</span><span class="p">):</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Walk parent: </span><span class="si">%s</span><span class="s2"> --&gt; </span><span class="si">%s</span><span class="s2">  &quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>
                        <span class="n">fringe</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="s1">&#39;tail&#39;</span><span class="p">))</span>
                        <span class="n">this_path</span><span class="p">[(</span><span class="n">w</span><span class="p">,</span> <span class="s1">&#39;tail&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s1">&#39;arrowhead&#39;</span><span class="p">)</span>
                        <span class="c1"># seen_links.append((v, w))</span>
                    <span class="c1"># Determine whether X and Y are connected</span>
                    <span class="c1"># (w, None) indicates the start or end node X/Y</span>
                    <span class="k">if</span> <span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="s1">&#39;tail&#39;</span><span class="p">)</span> <span class="ow">in</span> <span class="n">other_path</span> 
                       <span class="ow">or</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="s1">&#39;arrowhead&#39;</span><span class="p">)</span> <span class="ow">in</span> <span class="n">other_path</span>
                       <span class="ow">or</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">in</span> <span class="n">other_path</span><span class="p">):</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Found connection: &quot;</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
                        <span class="n">found_path</span> <span class="o">=</span> <span class="kc">True</span>   
                        <span class="k">break</span>
            <span class="k">return</span> <span class="n">found_path</span><span class="p">,</span> <span class="n">fringe</span><span class="p">,</span> <span class="n">this_path</span>

        <span class="k">def</span> <span class="nf">_walk_to_children</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">fringe</span><span class="p">,</span> <span class="n">this_path</span><span class="p">,</span> <span class="n">other_path</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Helper function to update paths when walking to children.&quot;&quot;&quot;</span>
            <span class="n">found_path</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_lagged_children</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">children</span><span class="p">):</span>
                <span class="c1"># You can also walk into conditioned children,</span>
                <span class="c1"># but cannot walk beyond t or max_lag</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">w</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="c1"># (w, v) not in seen_links and</span>
                    <span class="n">t</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">max_lag</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="s1">&#39;arrowhead&#39;</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">this_path</span> <span class="ow">and</span> 
                        <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">this_path</span><span class="p">):</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Walk child:  </span><span class="si">%s</span><span class="s2"> --&gt; </span><span class="si">%s</span><span class="s2">  &quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>
                        <span class="n">fringe</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="s1">&#39;arrowhead&#39;</span><span class="p">))</span>
                        <span class="n">this_path</span><span class="p">[(</span><span class="n">w</span><span class="p">,</span> <span class="s1">&#39;arrowhead&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s1">&#39;tail&#39;</span><span class="p">)</span>
                        <span class="c1"># seen_links.append((v, w))</span>
                    <span class="c1"># Determine whether X and Y are connected</span>
                    <span class="c1"># If the other_path contains w with a tail, then w must</span>
                    <span class="c1"># NOT be conditioned on. Alternatively, if the other_path</span>
                    <span class="c1"># contains w with an arrowhead, then w must be</span>
                    <span class="c1"># conditioned on.</span>
                    <span class="k">if</span> <span class="p">(((</span><span class="n">w</span><span class="p">,</span> <span class="s1">&#39;tail&#39;</span><span class="p">)</span> <span class="ow">in</span> <span class="n">other_path</span> <span class="ow">and</span> <span class="n">w</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">conds</span><span class="p">)</span>
                       <span class="ow">or</span> <span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="s1">&#39;arrowhead&#39;</span><span class="p">)</span> <span class="ow">in</span> <span class="n">other_path</span> <span class="ow">and</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">conds</span><span class="p">)</span>
                       <span class="ow">or</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">in</span> <span class="n">other_path</span><span class="p">):</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Found connection: &quot;</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
                        <span class="n">found_path</span> <span class="o">=</span> <span class="kc">True</span>   
                        <span class="k">break</span>
            <span class="k">return</span> <span class="n">found_path</span><span class="p">,</span> <span class="n">fringe</span><span class="p">,</span> <span class="n">this_path</span>

        <span class="k">def</span> <span class="nf">_walk_fringe</span><span class="p">(</span><span class="n">this_level</span><span class="p">,</span> <span class="n">fringe</span><span class="p">,</span> <span class="n">this_path</span><span class="p">,</span> <span class="n">other_path</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Helper function to walk each fringe, i.e., the path from X and Y,</span>
<span class="sd">            respectively.&quot;&quot;&quot;</span>
            <span class="n">found_path</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">mark</span> <span class="ow">in</span> <span class="n">this_level</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">conds</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">mark</span> <span class="o">==</span> <span class="s1">&#39;arrowhead&#39;</span> <span class="ow">or</span> <span class="n">mark</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
                        <span class="c1"># Motif: --&gt; [v] &lt;--</span>
                        <span class="c1"># If standing on a condition and coming from an</span>
                        <span class="c1"># arrowhead, you can only walk into parents</span>
                        <span class="p">(</span><span class="n">found_path</span><span class="p">,</span> <span class="n">fringe</span><span class="p">,</span>
                         <span class="n">this_path</span><span class="p">)</span> <span class="o">=</span> <span class="n">_walk_to_parents</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">fringe</span><span class="p">,</span> 
                                                       <span class="n">this_path</span><span class="p">,</span> <span class="n">other_path</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">found_path</span><span class="p">:</span> <span class="k">break</span>            
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">mark</span> <span class="o">==</span> <span class="s1">&#39;tail&#39;</span> <span class="ow">or</span> <span class="n">mark</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
                        <span class="c1"># Motif: &lt;-- v &lt;-- or &lt;-- v --&gt;</span>
                        <span class="c1"># If NOT standing on a condition and coming from</span>
                        <span class="c1"># a tail mark, you can walk into parents or </span>
                        <span class="c1"># children</span>
                        <span class="p">(</span><span class="n">found_path</span><span class="p">,</span> <span class="n">fringe</span><span class="p">,</span>
                         <span class="n">this_path</span><span class="p">)</span> <span class="o">=</span> <span class="n">_walk_to_parents</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">fringe</span><span class="p">,</span> 
                                                       <span class="n">this_path</span><span class="p">,</span> <span class="n">other_path</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">found_path</span><span class="p">:</span> <span class="k">break</span> 
                        
                        <span class="p">(</span><span class="n">found_path</span><span class="p">,</span> <span class="n">fringe</span><span class="p">,</span>
                         <span class="n">this_path</span><span class="p">)</span> <span class="o">=</span> <span class="n">_walk_to_children</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">fringe</span><span class="p">,</span> 
                                                       <span class="n">this_path</span><span class="p">,</span> <span class="n">other_path</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">found_path</span><span class="p">:</span> <span class="k">break</span> 
                      
                    <span class="k">elif</span> <span class="n">mark</span> <span class="o">==</span> <span class="s1">&#39;arrowhead&#39;</span><span class="p">:</span>
                        <span class="c1"># Motif: --&gt; v --&gt;</span>
                        <span class="c1"># If NOT standing on a condition and coming from</span>
                        <span class="c1"># an arrowhead mark, you can only walk into</span>
                        <span class="c1"># children</span>
                        <span class="p">(</span><span class="n">found_path</span><span class="p">,</span> <span class="n">fringe</span><span class="p">,</span>
                         <span class="n">this_path</span><span class="p">)</span> <span class="o">=</span> <span class="n">_walk_to_children</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">fringe</span><span class="p">,</span> 
                                                       <span class="n">this_path</span><span class="p">,</span> <span class="n">other_path</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">found_path</span><span class="p">:</span> <span class="k">break</span> 
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Updated fringe: &quot;</span><span class="p">,</span> <span class="n">fringe</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">found_path</span><span class="p">,</span> <span class="n">fringe</span><span class="p">,</span> <span class="n">this_path</span><span class="p">,</span> <span class="n">other_path</span>

        <span class="k">if</span> <span class="n">conds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">conds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">conds</span> <span class="o">=</span> <span class="p">[</span><span class="n">z</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">conds</span> <span class="k">if</span> <span class="n">z</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Y</span> <span class="ow">and</span> <span class="n">z</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">X</span><span class="p">]</span>

        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">link_coeffs</span><span class="p">)</span>
        <span class="n">children</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_children</span><span class="p">()</span>

        <span class="c1"># Iterate through nodes in X and Y</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">X</span><span class="p">:</span>
          <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">Y</span><span class="p">:</span>

            <span class="n">seen_links</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># predecessor and successors in search</span>
            <span class="c1"># (x, None) where None indicates start/end nodes, later (v,</span>
            <span class="c1"># &#39;tail&#39;) or (w, &#39;arrowhead&#39;) indicate how a link ends at a node</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="p">{(</span><span class="n">x</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span> <span class="kc">None</span><span class="p">}</span>
            <span class="n">succ</span> <span class="o">=</span> <span class="p">{(</span><span class="n">y</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span> <span class="kc">None</span><span class="p">}</span>

            <span class="c1"># initialize fringes, start with forward from X</span>
            <span class="n">forward_fringe</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>
            <span class="n">reverse_fringe</span> <span class="o">=</span> <span class="p">[(</span><span class="n">y</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>

            <span class="k">while</span> <span class="n">forward_fringe</span> <span class="ow">and</span> <span class="n">reverse_fringe</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">forward_fringe</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">reverse_fringe</span><span class="p">):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Walk from X since len(X_fringe)=</span><span class="si">%d</span><span class="s2"> &quot;</span>
                              <span class="s2">&quot;&lt;= len(Y_fringe)=</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">forward_fringe</span><span class="p">),</span> 
                                <span class="nb">len</span><span class="p">(</span><span class="n">reverse_fringe</span><span class="p">)))</span>
                    <span class="n">this_level</span> <span class="o">=</span> <span class="n">forward_fringe</span>
                    <span class="n">forward_fringe</span> <span class="o">=</span> <span class="p">[]</span>    
                    <span class="p">(</span><span class="n">found_path</span><span class="p">,</span> <span class="n">forward_fringe</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> 
                     <span class="n">succ</span><span class="p">)</span> <span class="o">=</span> <span class="n">_walk_fringe</span><span class="p">(</span><span class="n">this_level</span><span class="p">,</span> <span class="n">forward_fringe</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> 
                                                <span class="n">succ</span><span class="p">)</span>
                    <span class="c1"># print(pred)</span>
                    <span class="k">if</span> <span class="n">found_path</span><span class="p">:</span> <span class="k">return</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Walk from Y since len(X_fringe)=</span><span class="si">%d</span><span class="s2"> &quot;</span>
                              <span class="s2">&quot;&gt; len(Y_fringe)=</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">forward_fringe</span><span class="p">),</span> 
                                <span class="nb">len</span><span class="p">(</span><span class="n">reverse_fringe</span><span class="p">)))</span>
                    <span class="n">this_level</span> <span class="o">=</span> <span class="n">reverse_fringe</span>
                    <span class="n">reverse_fringe</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="p">(</span><span class="n">found_path</span><span class="p">,</span> <span class="n">reverse_fringe</span><span class="p">,</span> <span class="n">succ</span><span class="p">,</span> 
                     <span class="n">pred</span><span class="p">)</span> <span class="o">=</span> <span class="n">_walk_fringe</span><span class="p">(</span><span class="n">this_level</span><span class="p">,</span> <span class="n">reverse_fringe</span><span class="p">,</span> <span class="n">succ</span><span class="p">,</span> 
                                                <span class="n">pred</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">found_path</span><span class="p">:</span> <span class="k">return</span> <span class="kc">True</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;X_fringe = </span><span class="si">%s</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">forward_fringe</span><span class="p">)</span> <span class="o">+</span>
                          <span class="s2">&quot;Y_fringe = </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">reverse_fringe</span><span class="p">))</span>           

        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_is_dsep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">max_lag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">compute_ancestors</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns whether X and Y are d-separated given Z in the graph.</span>

<span class="sd">        X, Y, Z are of the form (var, lag) for lag &lt;= 0. D-separation is</span>
<span class="sd">        based on:</span>

<span class="sd">        1. Assessing maximum time lag max_lag of last ancestor of any X, Y, Z</span>
<span class="sd">        with non-blocked (by Z), non-repeating directed path towards X, Y, Z</span>
<span class="sd">        in the graph. &#39;non_repeating&#39; means that an ancestor X^i_{ t-\tau_i}</span>
<span class="sd">        with link X^i_{t-\tau_i} --&gt; X^j_{ t-\tau_j} is only included if</span>
<span class="sd">        X^i_{t&#39;-\tau_i} --&gt; X^j_{ t&#39;-\tau_j} for t&#39;!=t is not already part of</span>
<span class="sd">        the ancestors.</span>

<span class="sd">        2. Using the time series graph truncated at max_lag we then test</span>
<span class="sd">        d-separation between X and Y conditional on Z using breadth-first</span>
<span class="sd">        search of non-blocked paths according to d-separation rules.</span>

<span class="sd">        Optionally makes available the ancestors up to max_lag of X, Y,</span>
<span class="sd">        Z. This may take a very long time, however.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X, Y, Z : list of tuples</span>
<span class="sd">            List of variables chosen for current independence test.</span>
<span class="sd">        max_lag : int, optional (default: None)</span>
<span class="sd">            Used here to constrain the _is_dsep function to the graph</span>
<span class="sd">            truncated at max_lag instead of identifying the max_lag from</span>
<span class="sd">            ancestral search.</span>
<span class="sd">        compute_ancestors : bool</span>
<span class="sd">            Whether to also make available the ancestors for X, Y, Z as</span>
<span class="sd">            self.anc_all_x, self.anc_all_y, and self.anc_all_z, respectively.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dseparated : bool</span>
<span class="sd">            True if X and Y are d-separated given Z in the graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">link_coeffs</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Testing X=</span><span class="si">%s</span><span class="s2"> d-sep Y=</span><span class="si">%s</span><span class="s2"> given Z=</span><span class="si">%s</span><span class="s2"> in TSG&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">max_lag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># max_lags = dict([(j, max_lag) for j in range(N)])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Set max. time lag to: &quot;</span><span class="p">,</span> <span class="n">max_lag</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Get maximum non-repeated ancestral time lag</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">max_lag_X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_non_blocked_ancestors</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="n">Z</span><span class="p">,</span> 
                                                           <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;non_repeating&#39;</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">max_lag_Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_non_blocked_ancestors</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="n">Z</span><span class="p">,</span> 
                                                           <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;non_repeating&#39;</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">max_lag_Z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_non_blocked_ancestors</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="n">Z</span><span class="p">,</span> 
                                                           <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;non_repeating&#39;</span><span class="p">)</span>

            <span class="c1"># Get max time lag among the ancestors</span>
            <span class="n">max_lag</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_lag_X</span><span class="p">,</span> <span class="n">max_lag_Y</span><span class="p">,</span> <span class="n">max_lag_Z</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Max. non-repeated ancestral time lag: &quot;</span><span class="p">,</span> <span class="n">max_lag</span><span class="p">)</span>

        <span class="c1"># Store overall max. lag </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_lag</span> <span class="o">=</span> <span class="n">max_lag</span>


        <span class="c1"># _has_any_path is the main function that searches open paths</span>
        <span class="n">any_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_any_path</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="n">Z</span><span class="p">,</span> <span class="n">max_lag</span><span class="o">=</span><span class="n">max_lag</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;_has_any_path = &quot;</span><span class="p">,</span> <span class="n">any_path</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">any_path</span><span class="p">:</span>
            <span class="n">dseparated</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dseparated</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">compute_ancestors</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Compute ancestors.&quot;</span><span class="p">)</span>

            <span class="c1"># Get ancestors up to maximum ancestral time lag incl. repeated</span>
            <span class="c1"># links</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">anc_all_x</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_non_blocked_ancestors</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="n">Z</span><span class="p">,</span>
                                            <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;max_lag&#39;</span><span class="p">,</span> <span class="n">max_lag</span><span class="o">=</span><span class="n">max_lag</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">anc_all_y</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_non_blocked_ancestors</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="n">Z</span><span class="p">,</span>
                                            <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;max_lag&#39;</span><span class="p">,</span> <span class="n">max_lag</span><span class="o">=</span><span class="n">max_lag</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">anc_all_z</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_non_blocked_ancestors</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="n">Z</span><span class="p">,</span>
                                            <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;max_lag&#39;</span><span class="p">,</span> <span class="n">max_lag</span><span class="o">=</span><span class="n">max_lag</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dseparated</span>

<div class="viewcode-block" id="OracleCI.run_test"><a class="viewcode-back" href="../../../index.html#tigramite.independence_tests.OracleCI.run_test">[docs]</a>    <span class="k">def</span> <span class="nf">run_test</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tau_max</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">cut_off</span><span class="o">=</span><span class="s1">&#39;2xtau_max&#39;</span><span class="p">,</span>
                 <span class="n">compute_ancestors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">verbosity</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform oracle conditional independence test.</span>

<span class="sd">        Calls the d-separation function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X, Y, Z : list of tuples</span>
<span class="sd">            X,Y,Z are of the form [(var, -tau)], where var specifies the</span>
<span class="sd">            variable index in the observed_vars and tau the time lag.</span>
<span class="sd">        tau_max : int, optional (default: 0)</span>
<span class="sd">            Not used here.</span>
<span class="sd">        cut_off : {&#39;2xtau_max&#39;, &#39;max_lag&#39;, &#39;max_lag_or_tau_max&#39;}</span>
<span class="sd">            Not used here.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        val, pval : Tuple of floats</span>
<span class="sd">            The test statistic value and the p-value.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Translate from observed_vars index to full variable set index</span>
        <span class="n">X</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">observed_vars</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">X</span><span class="p">]</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">observed_vars</span><span class="p">[</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">Y</span><span class="p">]</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">observed_vars</span><span class="p">[</span><span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">Z</span><span class="p">]</span>

        <span class="c1"># Get the array to test on</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_XYZ</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">))</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dsepsets</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dsepsets</span><span class="p">[</span><span class="nb">str</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">))]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_dsep</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> 
                <span class="n">max_lag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">compute_ancestors</span><span class="o">=</span><span class="n">compute_ancestors</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dsepsets</span><span class="p">[</span><span class="nb">str</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">))]:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">pval</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="mf">1.</span>
            <span class="n">pval</span> <span class="o">=</span> <span class="mf">0.</span>

        <span class="k">if</span> <span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_print_cond_ind_results</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="n">val</span><span class="p">,</span> <span class="n">pval</span><span class="o">=</span><span class="n">pval</span><span class="p">,</span> <span class="n">cached</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                         <span class="n">conf</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="c1"># Return the value and the pvalue</span>
        <span class="k">return</span> <span class="n">val</span><span class="p">,</span> <span class="n">pval</span></div>

<div class="viewcode-block" id="OracleCI.get_measure"><a class="viewcode-back" href="../../../index.html#tigramite.independence_tests.OracleCI.get_measure">[docs]</a>    <span class="k">def</span> <span class="nf">get_measure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tau_max</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns dependence measure.</span>

<span class="sd">        Returns 0 if X and Y are d-separated given Z in the graph and 1 else.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X, Y [, Z] : list of tuples</span>
<span class="sd">            X,Y,Z are of the form [(var, -tau)], where var specifies the</span>
<span class="sd">            variable index in the observed_vars and tau the time lag.</span>

<span class="sd">        tau_max : int, optional (default: 0)</span>
<span class="sd">            Maximum time lag. This may be used to make sure that estimates for</span>
<span class="sd">            different lags in X, Z, all have the same sample size.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        val : float</span>
<span class="sd">            The test statistic value.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Translate from observed_vars index to full variable set index</span>
        <span class="n">X</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">observed_vars</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">X</span><span class="p">]</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">observed_vars</span><span class="p">[</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">Y</span><span class="p">]</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">observed_vars</span><span class="p">[</span><span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">Z</span><span class="p">]</span>

        <span class="c1"># Check XYZ</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">_check_XYZ</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">))</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dsepsets</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dsepsets</span><span class="p">[</span><span class="nb">str</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">))]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_dsep</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> 
                <span class="n">max_lag</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dsepsets</span><span class="p">[</span><span class="nb">str</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">))]:</span>
            <span class="k">return</span> <span class="mf">0.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.</span></div>

    <span class="k">def</span> <span class="nf">_print_cond_ind_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">pval</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cached</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">conf</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print results from conditional independence test.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        val : float</span>
<span class="sd">            Test stastistic value.</span>
<span class="sd">        pval : float, optional (default: None)</span>
<span class="sd">            p-value</span>
<span class="sd">        conf : tuple of floats, optional (default: None)</span>
<span class="sd">            Confidence bounds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">printstr</span> <span class="o">=</span> <span class="s2">&quot;        val = </span><span class="si">%.3f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span>      
        <span class="k">if</span> <span class="n">pval</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">printstr</span> <span class="o">+=</span> <span class="s2">&quot; | pval = </span><span class="si">%.5f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">pval</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">conf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">printstr</span> <span class="o">+=</span> <span class="s2">&quot; | conf bounds = (</span><span class="si">%.3f</span><span class="s2">, </span><span class="si">%.3f</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">conf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">conf</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">cached</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">printstr</span> <span class="o">+=</span> <span class="s2">&quot; </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">({</span><span class="mi">0</span><span class="p">:</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="s2">&quot;[cached]&quot;</span><span class="p">}[</span><span class="n">cached</span><span class="p">])</span>

        <span class="nb">print</span><span class="p">(</span><span class="n">printstr</span><span class="p">)</span>

<div class="viewcode-block" id="OracleCI.get_model_selection_criterion"><a class="viewcode-back" href="../../../index.html#tigramite.independence_tests.OracleCI.get_model_selection_criterion">[docs]</a>    <span class="k">def</span> <span class="nf">get_model_selection_criterion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">tau_max</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Base class assumption that this is not implemented.  Concrete classes</span>
<span class="sd">        should override when possible.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Model selection not&quot;</span><span class="o">+</span>\
                                  <span class="s2">&quot; implemented for </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">measure</span><span class="p">)</span></div></div>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>

    <span class="kn">import</span> <span class="nn">tigramite.plotting</span> <span class="k">as</span> <span class="nn">tp</span>
    <span class="kn">from</span> <span class="nn">matplotlib</span> <span class="k">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
    <span class="k">def</span> <span class="nf">lin_f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">x</span>

    <span class="c1"># N = 20</span>
    <span class="c1"># links = tests.a_random_process(</span>
    <span class="c1">#  N=N, L=2*N, coupling_coeffs=[0.7, -0.7],</span>
    <span class="c1">#  coupling_funcs=[lin_f, lin_f], auto_coeffs=[0., 0.5],</span>
    <span class="c1">#  tau_max=5, contemp_fraction=0.3, num_trials=1,</span>
    <span class="c1">#  model_seed=3)</span>

    <span class="c1"># N = 50</span>
    <span class="c1"># links = {0: [((0, -1), 0.5)]}</span>
    <span class="c1"># for j in range(1, N):</span>
    <span class="c1">#     links[j] = [((j, -1), 0.6), ((j-1, -1), 0.5)]</span>

    <span class="c1"># links = {0: [((0, -1), 0.5)],</span>
    <span class="c1">#          1: [((0, -1), 0.5), ((2, -1), 0.5)],</span>
    <span class="c1">#          2: [((2, -1), 0.)],</span>
    <span class="c1">#          3: [((3, -1), 0.), ((2, -1), 0.5), ((4, -1), 0.5)],</span>
    <span class="c1">#          4: [((4, -1), 0.5),],</span>
    <span class="c1">#          }</span>

    <span class="c1"># links = {0: [((0, -1), 0.)],</span>
    <span class="c1">#          1: [((1, -1), 0.)],</span>
    <span class="c1">#          2: [((2, -1), 0.), ((1, 0), 0.6), ((0, 0), 0.6)],</span>
    <span class="c1">#          3: [((3, -1), 0.), ((2, 0), -0.5)],</span>
    <span class="c1">#          }</span>

    <span class="c1"># links = {0: [((0, -1), 0.9)],</span>
    <span class="c1">#          1: [((1, -1), 0.8, lin_f), ((0, -1), 0.8, lin_f)],</span>
    <span class="c1">#          2: [((2, -1), 0.7, lin_f), ((1, 0), 0.6, lin_f)],</span>
    <span class="c1">#          3: [((3, -1), 0.7, lin_f), ((2, 0), -0.5, lin_f)],</span>
    <span class="c1">#          }</span>

    <span class="c1"># links = {0: [((0, -1), 0.5)],</span>
    <span class="c1">#          1: [((0, -1), 0.5), ((2, -1), 0.5)],</span>
    <span class="c1">#          2: [],</span>
    <span class="c1">#          3: [((2, -1), 0.4), ((4, -1), -0.5)],</span>
    <span class="c1">#          4: [((4, -1), 0.4)],</span>
    <span class="c1">#          }</span>

    <span class="c1"># def setup_nodes(auto_coeff, N):</span>
    <span class="c1">#     link_coeffs = {}</span>
    <span class="c1">#     for j in range(N):</span>
    <span class="c1">#        link_coeffs[j] = [((j, -1), auto_coeff, lin_f)]</span>
    <span class="c1">#     return link_coeffs</span>
    <span class="c1"># coeff = 0.5</span>

    <span class="c1"># link_coeffs = setup_nodes(0.7, N=3)</span>
    <span class="c1"># for i in [0, 2]:</span>
    <span class="c1">#     links[1].append(((i, 0), coeff, lin_f))</span>


    <span class="c1"># links = setup_nodes(0., N=3)</span>
    <span class="c1"># links[1].append(((1, -1), coeff, lin_f))</span>
    <span class="c1"># links[1].append(((0, 0), coeff, lin_f))</span>
    <span class="c1"># links[2].append(((1, 0), coeff, lin_f))</span>
    <span class="c1"># links[2].append(((0, 0), coeff, lin_f))</span>
    <span class="n">coeff</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="n">links</span> <span class="o">=</span><span class="p">{</span>
            <span class="mi">0</span><span class="p">:</span> <span class="p">[],</span>
            <span class="mi">1</span><span class="p">:</span> <span class="p">[((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">coeff</span><span class="p">,</span> <span class="n">lin_f</span><span class="p">),</span> <span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">coeff</span><span class="p">,</span> <span class="n">lin_f</span><span class="p">)],</span>
            <span class="mi">2</span><span class="p">:</span> <span class="p">[],</span>
            <span class="mi">3</span><span class="p">:</span> <span class="p">[((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">coeff</span><span class="p">,</span> <span class="n">lin_f</span><span class="p">)],</span>                                
            <span class="p">}</span>
    <span class="n">observed_vars</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

    <span class="n">X</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="c1">#(1, -3), (1, -2), (0, -2), (0, -1), (0, -3)]</span>
  <span class="c1">#(j, -2) for j in range(N)] + [(j, 0) for j in range(N)]</span>

    <span class="c1"># print(oracle._get_non_blocked_ancestors(Z, Z=None, mode=&#39;max_lag&#39;,</span>
    <span class="c1">#                                     max_lag=2))</span>
    <span class="n">cond_ind_test</span> <span class="o">=</span> <span class="n">OracleCI</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">observed_vars</span><span class="o">=</span><span class="n">observed_vars</span><span class="p">,</span> <span class="n">verbosity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="n">cond_ind_test</span><span class="o">.</span><span class="n">run_test</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="o">=</span><span class="n">Z</span><span class="p">))</span>
   
    <span class="c1"># anc_x=None  #oracle.anc_all_x[X[0]]</span>
    <span class="c1"># anc_y=None #oracle.anc_all_y[Y[0]]</span>
    <span class="c1"># anc_xy=None # []</span>
    <span class="c1"># # for z in Z:</span>
    <span class="c1"># #     anc_xy += oracle.anc_all_z[z]</span>
    
    <span class="c1"># fig, ax = tp.plot_tsg(links, </span>
    <span class="c1">#             X=[(observed_vars[x[0]], x[1]) for x in X], </span>
    <span class="c1">#             Y=[(observed_vars[y[0]], y[1]) for y in Y], </span>
    <span class="c1">#             Z=[(observed_vars[z[0]], z[1]) for z in Z],</span>
    <span class="c1">#     anc_x=anc_x, anc_y=anc_y, </span>
    <span class="c1">#     anc_xy=anc_xy)</span>

    <span class="c1"># fig.savefig(&quot;/home/rung_ja/Downloads/tsg.pdf&quot;)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Tigramite 4.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, Jakob Runge.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.1.2.
    </div>
  </body>
</html>